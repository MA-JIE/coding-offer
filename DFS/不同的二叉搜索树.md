给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

输入：n = 3
输出：5
示例 2：

输入：n = 1
输出：1

``` cpp
#include <vector>
class Solution {
public:
    int numTrees(int n) {
        std::vector<int> g(n+1,0);
        g[0] = 1;
        g[1] = 1;
        for(int i = 2; i <=n; ++i){
            for(int j = 1; j <= i; ++j){
                g[i] += g[j-1]*g[i-j];
            }
        }
        return g[n];
    }
};
```
解释：
这是一个经典的动态规划问题，我们可以使用卡塔兰数的方法来解决。

定义两个函数：

G(n): 长度为n的序列能构成的不同二叉搜索树的个数。

F(i, n): 以i为根、序列长度为n的不同二叉搜索树个数 (1≤i≤n)。

不难发现，G(n)是我们希望解决的问题。为了计算这个函数，我们可以考虑使用以下策略：每个数字都可能作为二叉搜索树的根，然后左右子树可以递归地由剩余的数字构造。于是，我们可以得到以下公式：

G(n) = F(1, n) + F(2, n) + ... + F(n, n)

特别地，对于边界情况，当序列长度为1（只有根）或为0（空树）时，只有一种情况。亦即：

G(0)=1, G(1)=1

给定序列1⋯n，我们选出数字i（1≤i≤n）作为根，则根为i的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，于是我们可以得到以下公式：

F(i, n) = G(i-1) * G(n-i)

将以上两个公式结合，可以得到卡塔兰数的递推公式：

G(n) = G(0) * G(n-1) + G(1) * G(n-2) + ... + G(n-1) * G(0)
