# 有效的数独
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可. <br>
数字 1-9 在每一行只能出现一次. <br>
数字 1-9 在每一列只能出现一次. <br>
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次. <br>
示例: <br>
输入: <br>
[
  ["5","3",".",".","7",".",".",".","."], <br>
  ["6",".",".","1","9","5",".",".","."], <br>
  [".","9","8",".",".",".",".","6","."], <br>
  ["8",".",".",".","6",".",".",".","3"],  <br>
  ["4",".",".","8",".","3",".",".","1"],  <br>
  ["7",".",".",".","2",".",".",".","6"], <br>
  [".","6",".",".",".",".","2","8","."],  <br>
  [".",".",".","4","1","9",".",".","5"], <br>
  [".",".",".",".","8",".",".","7","9"]  <br>
] <br>
输出: true <br>
思路:对每行,每列,每个box都构建对应的二维数组,实现hash map的形式, 第一维代表对应行,列和box的索引,第二维代表1~9十个数字的值,从(0,0)开始遍历,若之前没有对应元素出现,就将其置为"1". <br>
```cpp
class Solution
{
public:
    bool isValidSudoku(vector<vector<char>> &board)
    {
        //第一维代表1~9行或列,第二维代表数字1~9
        int row[9][10] = {0};
        int col[9][10] = {0};
        //第一维代表9个box,第二维代表数字1~9
        int box[9][10] = {0};
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] == '.')
                {
                    continue;
                }
                int currentnum = board[i][j] - '0';
                if (row[i][currentnum])
                    return false;
                if (col[j][currentnum])
                    return false;
                //i / 3 + (j / 3) * 3代表9个box中对应的box索引
                if (box[i / 3 + (j / 3) * 3][currentnum])
                    return false;
                row[i][currentnum] = 1;
                col[j][currentnum] = 1;
                box[i / 3 + (j / 3) * 3][currentnum] = 1;
            }
        }
        return true;
    }
};
```
