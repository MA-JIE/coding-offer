# 单例模式
作用：保证一个类只有一个实例，并提供一个访问它的全局访问点，使得系统中只有唯一的一个对象实例. <br>
应用：常用于管理资源，如日志、线程池 <br>
实现要点:<br>
在类中，要构造一个实例，就必须调用类的构造函数，并且为了保证全局只有一个实例,需防止在外部调用类的构造函数而构造实例，需要将构造函数的访问权限标记为private,同时阻止拷贝创建对象时赋值时拷贝对象，因此也将它们声明并权限标记为private; <br>
另外，需要提供一个全局访问点，就需要在类中定义一个static函数，返回在类内部唯一构造的实例. <br>
```cpp
class Singleton{
public:
    static Singleton &getInstance()
    {
        static Singleton instance;
        return instance;
    }
    void printTest()
    {
        std::cout << "do something" << endl;
    }

private:
    Singleton(){};                                    //防止外部调用构造创建对象
    Singleton(Singleton const &singleton);            //阻止拷贝创建对象
    Singleton &operator=(Singleton const &singleton); //阻止赋值对象
};
int main()
{
    Singleton &a = Singleton::getInstance();
    a.printTest();
    return 0;
}
```
首先，构造函数声明成private的目的是只允许内部调用，getInstance()中的静态局部变量创建时调用，但不允许外部调用构造创建第二个实例; <br>
然后，拷贝构造和拷贝赋值符是声明成了private而不给出定义，其目的是阻止拷贝，如果企图通过拷贝构造来创建第二个实例，编译器会报错.<br>
阻止拷贝的另一种写法是声明后接一个"=delete",也能起到相同的作用（C++11).<br>
