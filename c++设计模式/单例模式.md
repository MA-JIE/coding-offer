# 单例模式
* 作用: <br>
证一个类只有一个实例，并提供一个访问它的全局访问点，使得系统中只有唯一的一个对象实例.许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息.这种方式简化了在复杂环境下的配置管理.<br>
应用：常用于管理资源，如日志、线程池 <br>
* 实现要点:<br>
 一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称);当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用; 同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例,同时阻止拷贝创建对象时赋值时拷贝对象，因此也将它们声明并权限标记为private,另外，需要提供一个全局访问点，就需要在类中定义一个static函数，返回在类内部唯一构造的实例 <br> 
 * 需要注意的地方: <br>
 单例模式在多线程的应用场合下必须小心使用.如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则. 解决这个问题的办法是为指示类是否已经为实例化的变量提供一个互斥锁(虽然这样会降低效率). <br>
在类中，要构造一个实例，就必须调用类的构造函数，并且为了保证全局只有一个实例,需防止在外部调用类的构造函数而构造实例，需要将构造函数的访问权限标记为private. <br>
* 优点 <br>
1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例. 这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例. <br> 
2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性. <br> 
3.提供了对唯一实例的受控访问. <br>
4.由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能. <br> 
5.允许可变数目的实例. <br>
6.避免对共享资源的多重占用. <br>
* 缺点 <br>
1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态. <br> 
2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难.<br> 
3.单例类的职责过重，在一定程度上违背了“单一职责原则”. <br> 
4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失.<br>
* 适用场景: <br>
单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。如： 
1.需要频繁实例化然后销毁的对象. <br>
2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象. <br> 
3.有状态的工具类对象. <br>
4.频繁访问数据库或文件的对象. <br>
以下都是单例模式的经典使用场景: <br>
1.资源共享的情况下，避免由于资源操作时导致的性能或损耗等. 如上述中的日志文件，应用配置. <br> 
2.控制资源的情况下，方便资源之间的互相通信. 如线程池等,多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。<br>
* 实现单利模式的原则和过程： 
1.单例模式：确保一个类只有一个实例，自行实例化并向系统提供这个实例 . <br>
2.单例模式分类：饿单例模式（类加载时实例化一个对象给自己的引用），懒单例模式（调用取得实例的方法如getInstance时才会实例化对象）（java中饿单例模式性能优于懒单例模式，c++中一般使用懒单例模式）<br> 
3.单例模式要素: <br> 
a.私有构造方法  <br>
b.私有静态引用指向自己实例 <br>
c.以自己实例为返回值的公有静态方法 <br>
```cpp
class Singleton{
public:
    static Singleton &getInstance()
    {
        static Singleton instance;
        return instance;
    }
    void printTest()
    {
        std::cout << "do something" << endl;
    }

private:
    Singleton(){};                                    //防止外部调用构造创建对象
    Singleton(Singleton const &singleton);            //阻止拷贝创建对象
    Singleton &operator=(Singleton const &singleton); //阻止赋值对象
};
int main()
{
    Singleton &a = Singleton::getInstance();
    a.printTest();
    return 0;
}
```
首先，构造函数声明成private的目的是只允许内部调用，getInstance()中的静态局部变量创建时调用，但不允许外部调用构造创建第二个实例; <br>
然后，拷贝构造和拷贝赋值符是声明成了private而不给出定义，其目的是阻止拷贝，如果企图通过拷贝构造来创建第二个实例，编译器会报错.<br>
阻止拷贝的另一种写法是声明后接一个"=delete",也能起到相同的作用（C++11).<br>
# 饿汉式(单例实例在类装载时就构建，急切初始化)
```cpp
public class Test {
        private Test() {
        }
        public static Test instance = new Test();
        public Test getInstance() {
                return instance;
        }
}
```
* 优点 <br>
1.线程安全 <br> 
2.在类加载的同时已经创建好一个静态对象，调用时反应速度快 <br> 
* 缺点 <br>
资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 <br> 

# 懒汉式(单例实例在第一次被使用时构建，延迟初始化)
```cpp
class Test {
        private Test() {
        }
        public static Test instance = null;
        public static Test getInstance() {
                if (instance == null) {
              //多个线程判断instance都为null时，在执行new操作时多线程会出现重复情况
                        instance = new Singleton2();
                }
                return instance;
        }
}
```
优点: <br> 
避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法. <br> 
缺点: <br> 
懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大. <br>
