# 1. C和C++的区别
1. C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出；<br>
C++是面向对象的语言，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。<br>
2. C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。<br>
3. C++支持函数重载，C不支持函数重载<br>
4. C++中有引用，C中不存在引用的概念<br>

# 2.#include<file.h>与#include "file.h"的区别
前者是从标准库路径寻找，后者是从当前工作路径寻找

# 3.C++文件编译与执行的四个阶段
1. 预处理：根据文件中的预处理指令来修改源文件的内容 <br>
2. 编译：编译成汇编代码 <br>
3. 汇编：把汇编代码翻译成目标机器指令 <br>
4. 链接：链接目标代码生成可执行程序 <br>

# 4.堆和栈有什么区别
一、堆栈空间分配区别: <br>
1、栈（操作系统）: 由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈; <br>
2、堆（操作系统）: 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表. <br>
二、堆栈缓存方式区别: <br>
1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放;<br>
2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收).所以调用这些对象的速度要相对来得低一些. <br>
三、堆栈数据结构区别: <br>
堆（数据结构）: 堆可以被看成是一棵树，如：堆排序; <br>
栈（数据结构）: 一种先进后出的数据结构. <br>
# 5.深拷贝和浅拷贝的区别
[深拷贝&&浅拷贝](深拷贝&&浅拷贝.md)

# 6.什么是面向对象（OOP）
面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想.<br>

# 7.什么是多态？
多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态. <br>

# 8.STL库用过吗？常见的STL容器有哪些？算法用过哪几个？
STL包括两部分内容：容器和算法。（重要的还有融合这二者的迭代器）<br>
容器，即存放数据的地方。比如array等。<br>
在STL中，容器分为两类：序列式容器和关联式容器。<br>
序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；<br>
关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。<br>
下面各选取一个作为说明:<br>
vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间. <br>
set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值. <br>
算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容: <br>
迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计. <br>
# 9.类的static变量在什么时候初始化? 函数的static变量在什么时候初始化?
类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化. <br>
# 10.解释下封装、继承和多态?
一、封装: <br>
封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中(我们称之为类). <br>
封装的意义在于保护或者防止代码（数据）被我们无意中破坏. <br>
二、继承: <br>
继承主要实现重用代码，节省开发时间. <br>
子类可以继承父类的一些东西. <br>
三、多态 <br>
多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法. <br>
# 11.指针和引用的区别
1. 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名, 比如: <br>
 ``` cpp
int a=1;int *p=&a;
int a=1;int &b=a;
```
上面定义了一个整形变量和一个指针变量p,该指针变量指向a的存储单元,即p的值是a存储单元的地址. <br>
而下面定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，相当于一个人有两个名字,但还是同一个人,在内存占有同一个存储单元. <br>
2. 引用使用时无需解引用(*)，指针需要解引用; <br>
3. 引用只能在定义时被初始化一次，之后不可变；指针可变; <br>
4. )可以有const指针，但是没有const引用; <br>
5. 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化,指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了. <br>
6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小; <br>
7. 指针和引用的自增(++)运算意义不一样; <br>
8. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）<br>
9.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域. <br>
具体用例参考: <br>
[指针和引用的区别](指针和引用的区别.md)

# 12. 什么是内存泄漏? 面对内存泄漏和指针越界,你有哪些方法? 你通常采用哪些方法来避免和减少这类错误?
用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露.<br>
使用的时候要记得指针的长度.<br>
malloc的时候得确定在那里free.<br>
对指针赋值的时候应该注意被赋值指针需要不需要释放.<br>
动态分配内存的指针最好不要再次赋值.<br>
# 13. 常用的排序算法有哪些? 简单描述几个排序算法的优缺点?
答：选择、冒泡、快速、希尔、归并、堆排等<br>
1.快排：是冒泡排序的一种改进<br>
优点：快，数据移动少 <br>
缺点：稳定性不足 <br>
2.归并：分治法排序，稳定的排序算法，一般用于对总体无序，但局部有序的数列 <br>
优点：效率高O(n)，稳定 <br>
缺点：比较占用内存 <br>
[常见排序算法](常见排序算法.md)

# 14. new和malloc的区别？
1、malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存. <br>
2、对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数. <br>
3、由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数. <br>
4、C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存. <br>
5、new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针. <br>

# 15. 解释C++中静态函数和静态变量
(1)类静态数据成员在编译时创建并初始化：在该类的任何对象建立之前就存在，不属于任何对象，而非静态类成员变量则是属于对象所有的。类静态数据成员只有一个拷贝，为所有此类的对象所共享.<br>
(2)类静态成员函数属于整个类，不属于某个对象，由该类所有对象共享. <br>
1、static 成员变量实现了同类对象间信息共享. <br>
2、static 成员类外存储，求类大小，并不包含在内. <br>
3、static 成员是命名空间属于类的全局变量，存储在 data 区的rw段. <br>
4、static 成员只能类外初始化. <br>
5、可以通过类名访问（无对象生成时亦可），也可以通过对象访问. <br>

# 16. struct与class的区别
struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的. <br>
struct是一种数据结构的实现体，虽然它是可以像class一样的用.依旧将struct里的变量叫数据，class内的变量叫成员，虽然它们并无区别. <br>
在C++中struct得到了很大的扩充: <br>
1.struct可以包括成员函数 <br>
2.struct可以实现继承 <br>
3.struct可以实现多态 <br>
从语法上，在C++中class和struct做类型定义时只有两点区别: <br>
1. 默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理. <br>
2. 成员的默认访问权限. class的成员默认是private权限，struct默认是public权限. <br>
# 17.对迭代器的理解?
背景：指针可以用来遍历存储空间连续的数据结构，但是对于存储空间非连续的，就需要寻找一个行为类似指针的类，来对非数组的数据结构进行遍历。 
定义：迭代器是一种检查容器内元素并遍历元素的数据类型。 
迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围. <br> 
迭代器（Iterator）是指针（pointer）的泛化，它允许程序员用相同的方式处理不同的数据结构(容器). <br>
（1）迭代器类似于C语言里面的指针类型，它提供了对对象的间接访问. <br>
（2）指针是C语言中的知识点，迭代器是C++中的知识点。指针较灵活，迭代器功能较丰富. <br> 
（3）迭代器提供一个对容器对象或者string对象的访问方法，并定义了容器范围 <br>
# 18.std::vector中的迭代器什么时候失效?
1.当插入（push_back）一个元素后，end操作返回的迭代器肯定失效. <br>
2.当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操 作返回的迭代器都会失效.<br>
3.当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效. <br>
# 19. list 与 vector的区别?
1）vector底层实现是数组；list是双向 链表. <br>
2）vector支持随机访问，list不支持. <br>
3）vector是顺序内存，list不是. <br>
4）vector在中间节点进行插入删除会导致内存拷贝，list不会. <br>
5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请. <br>
6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好.<br>
vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector. <br>
list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list. <br>
# 20.什么时候需要explicit?
explicit可以抑制内置类型隐式转换,所以在类的构造函数中,最好尽可能多用explicit关键字,防止不必要的隐式转换. <br>
[explicit](explicit关键字.md) <br>
# 21.栈溢出,内存缓冲区溢出, 内存泄露的原因有哪些?
栈溢出: <br>
常见的栈溢出则是递归层次太深，为什么递归层次太深会导致栈溢出呢？我们知道程序分配空间的时候会给我们分配一个栈的空间供我们使用，在栈上保存了调用函数的一些信息，比如形参，以及一些其他信息，在函数退出后便将栈上空间归还。但是我们一直递归的调用，导致函数没有办法返回，也就没有办法将空间归还，一直循环下去，必定造成栈的空间使用完.其他造成栈空间的内存使用完的情况都大体类似，都是一直在向栈申请，导致栈无法满足需求. <br
内存缓冲区溢出: <br>
栈溢出就是缓冲区溢出的一种，就是往缓冲区写入太多东西. <br>
内存泄露: <br>
内存在申请后没有被及时释放. <br>
1、常发性内存泄漏：经常性的申请内存，但是没有释放. <br>
2、偶发性内存泄漏：偶尔性的申请却不释放，其实跟常发性一样，只是频率而已. <br>
3、一次性内存泄漏：只会发生一次，比如在构造函数中申请，而且这个对象只实例化一个. <br>
4、隐式内存泄漏：就是我们说的，运行期间申请，但是程序结束前才释放. <br>
# 22.多线程同步和互斥
线程同步: <br>
指线程之间所具有的一种制约关系，一个线程的执行依赖另外一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒.<br>
线程互斥: <br>
指对于共享的进程系统资源，每个线程访问时的排他性.当有若干个线程都要使用某一个共享资源时，任何时刻最多只允许一个线程去使用，其他线程必须等待，知道占用占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步. <br>

# 23.如何理解std::move()?
[std::move&&std::forward](move.md) <br>
